\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{amsmath,amssymb}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{steinmetz}
\usepackage{stackrel}
\usepackage{mathtools}
\newcommand{\angstrom}{\text{\normalfont\AA}}

\geometry{a4paper}

\usepackage[english]{babel}
\frenchspacing

\title{Report: adder and subtractor}
\author{Lorenzo Ramella, Alessandro Matteo Rossi, Marco Tambini}
\date{\today}

\begin{document}
\maketitle

\tableofcontents

\section{Basics concepts}

To make calculations, a circuit needs to be able to perform logical operations. In particular, we usually use boolean algebra in digital electronics. 

\vspace{3mm}

To be able to create a circuit like this, first of all, we need to define the various components.
The number 0 and 1 have to be properties of an electric circuit that can be "moved"; the easiest waof this proprieties to use is the voltage so we can assign the number 0 to a low voltage and the number 1 to a high voltage. 

\vspace{3mm}

For example, if we define $0\,\textrm{V}$ as low, negative or 0 and $5\,\textrm{V}$ as high, positive or 1, we can define a threshold voltage exactly in the middle, so that any voltage under $2.5\,\textrm{V}$ will be considered 0, and any voltage above it will be considered 1.

\vspace{3mm}

Once 1 and 0 are defined, we need to define the operations that can be performed:

\begin{itemize}
\item $"!"$ is the negation, and it can be represented by a NOT gate.
\item $"+"$ is the addition, and it can be represented by a OR gate.
\item $"*"$ is the multiplication, and it can be represented by an AND gate.
\end{itemize}

\section{Logic gates}

When we talk about a logic gate, we are talking about a circuit that can take a certain number of inputs and give a single output, depending on the input received; the output needs to be readable by another logic gate of the same family.

\vspace{3mm}

The main logic gates are the following, represented with their circuital symbol in figure \ref{LogicGates}.

\begin{figure}[h]

    \centering
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_NOT.PNG}
        \caption{NOT gate}
        \label{NOT}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_AND.PNG}
        \caption{AND gate}
        \label{AND}        
    \end{subfigure}
    
    \centering
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_OR.PNG}
        \caption{OR gate}
        \label{OR}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_XOR.PNG}
        \caption{XOR gate}
        \label{XOR}        
    \end{subfigure}
    
    \centering
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_NAND.PNG}
        \caption{NAND gate}
        \label{NAND}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_NOR.PNG}
        \caption{NOR gate}
        \label{NOR}        
    \end{subfigure}
    
    \centering
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_XNOR.PNG}
        \caption{XNOR gate}
        \label{XNOR}
    \end{subfigure}

\caption{Image of the main logic gates used in digital electronics}
\label{LogicGates}
\end{figure}


\subsection{NMOS}

In order to create these logic gates, we need to know how to use a MOSFET. For this project we used NMOS transistors only.

\vspace{3mm}

The NMOS is a transistor that gets as input a gate voltage, a drain voltage, a source voltage and a body voltage; in most cases the source and the body are internally connected, since the body needs to be at the lowest voltage and the source is usually earthed.

\vspace{3mm}

When a positive voltage is applied between the drain and source, a deplition layer block the passage of current is formed and there is no passage of current. 
If we then start applying a positive voltage between gate and body, the electrons will start "balancing" the gaps in the P substrate, but there will still be no current flow.

\vspace{3mm}

After $V_{GS}$ (the potential difference among gate and source) surpasseses a certain threshold voltage, the current will start to flow from drain to source. At the beginning of this flow, the ratio between the current and $V_{DS}$ (the potential difference among drain and source) is linear but, when $V_{DS}$ becomes big enough, the ratio stops its growth and becomes almost linear as seen in figure %number of immage
and we find ourself in the region of saturation.

\vspace{3mm}

We didn't really need to differentiate in linear section and saturation section of the NMOS since what we will check is the voltage at the drain of the NMOS for our gate. The threshold voltage is different for every transistor, and usually is within the range $0.5\,\textrm{V} - 5\,\textrm{V}$. The transistor we used is the $IRF822$, and we found in lag that the threshold voltage is approssimatively %nV
, we decided to use $5V$ for $V_{GS}$ to make, as we will see later, input and output aproximativaly the same.



\subsection{NOT gate}

The easiest logic gate to realize is the NOT gate; we remember that the NOT gate negates the input, and so it works with a single input. We need a high enough resistance and one NMOS (as represented in figure \ref{NOT_NMOS}) to realize it.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{IM_NOT_NMOS.JPG}
    \caption{NOT logic gate realized using a NMOS and a resistor}
    \label{NOT_NMOS}
\end{figure}

When the input is 0, the NMOS will not let the current flow and, thanks to Ohm First Law, we know that the voltage drop across the resistor should be 0, so we get the same supply voltage. The read output will be around $5\,\textrm{V}$, so we get a 1 output.

\vspace{3mm}

When the input is 1, the NMOS will let the current flow with a small resistance value; since there is a higher resistance before the NMOS, almost all the voltage drop will happen on the previous one, and the drain will be almost zero. The read output will be around $0\,\textrm{V}$, so we get a 0 output.

\vspace{3mm}

With this configuration the signal will not be properly negated for high frequencies, and it will be like in figure \ref{ResistiveInverter}
instead
and instead pass almost all the time in a 0 state. 

A possible solution consists of a combination of NMOS and PMOS but, since our calculator does not have to work at such frequencies, we dismissed this problem.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{IM_inverter_esa.PNG}
    \caption{Inverter NMOS circuit with a resistive load}
    \label{ResistiveInverter}
\end{figure}

For the immage of the NOT gate and some result we got in lab check the end of the report at %number of appendix chapter subsection not gate



\subsection{NOR gate}

Once we created the NOT gate, we proceeded to realize the NOR gate since, as we will explain later in Section \ref{OtherGates}, the NOR and the NAND gate are both functional complete.

The NOR gate is composed, as seen in figure \ref{NOR_NMOS}, by two NOT gates short-circuited at their output.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.3]{IM_NOR_NMOS.JPG}
    \caption{NOR logic gate realized using two short-circuited NOT gates}
    \label{NOR_NMOS}
\end{figure}

When both inputs are 0, the two NMOS will not let any current pass and, just like in the NOT gate, the output will be 1.

\vspace{1mm}

When one or both the inputs are 1 the NMOS will let the current flow and there will be a voltage drop across the resistor. So the output will be 0.

\vspace{1mm}

The role of the short circuit is to ensure that whether an input is positive, the current will pass throught the "open" NMOS.

\vspace{3mm}

For the immage of the NOR gate and some result we got in lab check the end of the report at %number of appendix chapter subsection nor gate

\subsection{NAND gate}

Like we said for the NOR gate, the NAND gate is also functional complete. But it can be created without the shortcircuit and without one of the resistors needed by the NOR gate, so it is slightly cheaper. 

\vspace{3mm}

The NAND gate is realized by a series resistor followed by two NMOS, where the source of the first is plugged in the drain of the second, as seen in figure \ref{NAND_NMOS}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.3]{IM_NAND_NMOS.JPG}
    \caption{NAND gate realized with one resistor and two NMOS transistors}
    \label{NAND_NMOS}
\end{figure}

Whether both inputs are 1, the current will be able to flow and the output will be 0.

\vspace{1mm}

When one of the inputs is 0, one of the NMOS will be "closed" and, since the current cannot pass, the output will be 1.

\vspace{3mm}

For the immage of the NAND gate and some result we got in lab check the end of the report at %number of appendix chapter subsection nand gate



\subsection{Other logic gates} \label{OtherGates}

Being functional complete means that a single logic can be the only component in a circuit, and that circuit will be equivalent to every other logic gate. NAND and NOR gates have this property. We could have created the NOT gate with the circuit shown in figure \ref{} in Appendix, instead of using a customized one. %number of immage about functional completness of NAND and NOR in appendix 

\clearpage

The only gates needed for the calculator are shown in figure \ref{UsefulGates}, and they are: 

\begin{itemize}
\item The AND gate, made by the NAND gate, where the output is negated by a NOT.
\item The OR gate, made by the NOR gate, where the output is negated by a NOT.
\item The XOR gate, made by four NAND gates.
\end{itemize}

\begin{figure}[h]
    \centering
    \begin{subfigure}[h]{\textwidth}
        \centering
        \includegraphics[scale=.3]{IM_AND_LOGIC.JPG}
        \caption{AND gate built using a negated NAND gate}
    \end{subfigure}
    \vspace{2mm}
    \begin{subfigure}[h]{\textwidth}
        \centering
        \includegraphics[scale=.3]{IM_OR_LOGIC.JPG}
        \caption{OR gate built using a negated NOR gate}       
    \end{subfigure}
    \vspace{2mm}
    \begin{subfigure}[h]{\textwidth}
        \centering
        \includegraphics[scale=.3]{IM_XOR_LOGIC.JPG}
        \caption{XOR gate built using a four NAND gates}          
    \end{subfigure}
    \caption{The logic gates used in the calculator}
    \label{UsefulGates}
\end{figure}

\subsection{Bistable circuit}

For the 16-bit calculator, that will be discussed in section \ref{SimulatedCalculator}, we also needed to be able to store information.

\vspace{1mm}

This means that we need a component that will work as memory. It has to be able to get an input and keep it saved as long as necessary, even if the input signal has already expired. Since the memory has to be both writable and readable, it needs a second input line to clear it.

\vspace{3mm}

The circuit that corresponds to the memory we need is the bistable circuit, also known as flip-flop (shown in figure \ref{FlipFlop}).

\begin{figure}[h]
    \centering
    \includegraphics[scale=.3]{IM_FlipFlop}
    \caption{The circuit used to create a flip-flop memory unit}
    \label{FlipFlop}   
\end{figure}

The flip-flop can be created by both NOR gates and NAND gates but, since the NAND gate are cheaper, we decided to use those. This meant that the input has to be negated in order to work properly. Flip flop truth table can be found in table \ref{FlipFlopTT}.


\begin{table}[h]
\centering
\begin{tabular}{ | c | c  c  c | c  c |}
\hline
 \# & $Set$ & $Clear$ & $Old Q$ & $New Q$ & $New Q'$\\
\hline
 \ 1 & 0 & 0 & 0 & 1 & 1 \\ 
 \ 2 & 0 & 0 & 1 & 1 & 1 \\
\hline 
 \ 3 & 0 & 1 & 0 & 1 & 0 \\ 
 \ 4 & 0 & 1 & 1 & 1 & 0 \\ 
 \ 5 & 1 & 0 & 0 & 0 & 1 \\
 \ 6 & 1 & 0 & 1 & 0 & 1 \\
\hline
 \ 7 & 1 & 1 & 0 & 0 & 1 \\
 \ 8 & 1 & 1 & 1 & 1 & 0 \\ 
\hline
\end{tabular}
\caption{Flip flop truth table. Please note that the first two rows are not ideal for the storage of memory, as $Q$ and $Q'$ have the same value. Rows 3, 4, 5 and 6 represent the moment when an input is give, whereas 7 and 8 is when data is stored.}
\label{FlipFlopTT}
\end{table}


\clearpage

\section{16-bit calculator} \label{SimulatedCalculator}



\subsection{Input with 16-bit}

Our goal is to create a 16-bit calculator. A calculator that could receive 16 bits as input and that produces 17 output bits (the 17th is the sign bit).

One of the problems that arise when we want to use such a big memory space is the increasement in complexity; this makes the circuit more expensive and also takes a lot of physical space, that could be used for other purposes. In a small scale we could use a 2-bit priority encoder, but for our project it would be unpractical and unnecessarily harder.

\vspace{3mm}

Another problem regarding the priority encoder, it that this componentthat would araise in that of the phisical input since  priority encoder would require as many input as the number of decimal number we want. %NON HO CAPITO MA SO COME RIFORMULARE

\vspace{3mm}

To solve both problems we decided to use a keyboard. It takes the input through some buttons, instead of the levers we used in the laboratory. This method solved both the problem with the number of inputs and the problem of the complexity of the decoder.



\subsection{Keyboard}

The keyboard part connects a point at high voltage to the rest of the circuits. It is composed by: 

\begin{itemize}
    \item 10 buttons for the digits from 0 to 9;
    \item An addition button labeled $+$;
    \item A subtraction button labeled $-$;
    \item A button to have the result displayed, labeled $=$;
    \item A clear button that resets the entire circuit.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=.3]{IM_Keyboard}
    \caption{Picture of the simulated circuited keyboard}
    \label{Keybaord}
\end{figure}

\clearpage

\subsection{4-bit encoder}
The first part of our encoder is a 4-bit encoder, without priority. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=.35]{IM_4BitEncoder.JPG}
    \caption{}
    \label{encoder}
\end{figure}

As you can see in figure \ref{encoder} this part can be split in three different sections:

\begin{itemize}
    \item The red part is a 4-bit encoder without priority. As we were saying in the paragraph above, the advantage of using a keyboard is that we will, under normal condition, only get 1 input at a time making a priority encoder useless. The encoder works by checking, with an OR gate, which bits the inserted number activates.
    
    \vspace{1mm}

    For example, if we press the button "6" the binary input will be $0110$, so only the second and the third bit will be activated.

    \item The green part is an OR gate connected to all the input lines, in order to check whether a button corresponding to a number is pressed. This choice has been made because if 0 were pressed, it should not result in any binary input but it would be read as the number "10". 

    \item The blue part is a small "flash memory", which gets cleared when the input button is no longer pressed. 
            
        This part, whose task will be discussed in the next subsection, is a simple "security" method useful to ensure that the inputs arrive correctly to the next memory. This part could be removed if the circuit timing was perfect, but we preferred to keep it to ensure no problem would arise.    
\end{itemize}


\subsection{Memory and successive inputs}

This part allows the circuit to receive that make possible to get consecutive inputs, and it is composed by two memories and two full adders. 

In this section the input gets stored and, after a new button is pressed, the stored number is multiplied by 10 and then added to the new input. By doing this we can obtain every number within the memory limit.

It is important to point out that this part works by using the concepts of "rising edge", where the input passes from a low state to a high one, and "falling edge", where the input changes from high to low. Using this concept it is possible to process a single input in two phases.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.55]{IM_Converter.PNG}
    \caption{}
    \label{Converter}
\end{figure}


\subsubsection{Rising edge}

When the first button is pressed the circuit is in a state of rising edge. Right after a button is pressed the line that go to the NAND of the second memory, highlighted in yellow Immage %number of immage
, switch to low preventing the NAND to let any signal pass from the first to the second memory.

The second line that change is the one under the first memory (highlighted in green) that also turn off; this is the line that is responsible of the clearing of the memory and, when it switch from high to low, it reset the memory.

After a little while the last line that change is the one on top of the first memory that let the input be memorized in the cleared memory.

\vspace{3mm}

It's important to note that, during the storage of data, the reset button is in a low state since it cleared the memory right before the storage of new data.

This statement don't pose problem when the input is 0 since we find ourself in the case 5 or 6 of the flip-flop truth table in chapter %chapter of the flip flop
and, as you can see, the output is 0. 

The problem arise when the input data is 1 since we find ourself in case 1 or 2 where the two input are 0; as we can see in the truth table both output are set at 1.

After one of the two input switch from low to high the flip-flop return in a normal state; what we want is to go from the state above to the state 4 of the table of truth; this mean that, as long as the first line to return to high is the one for the reset, we see no problem.

\vspace{3mm}

The problem we just described is solved in the simulated calculator we have done by using the delay of the logic gate; in reality this could be a problem since this rely on physical propieties that could be dependant on temperature rendering this kind of timing not as precise as in the simulator.

The problem of the tempistic also include the fact that the operation on the second memory sould be done before the one of the first memory; in our circuit the delay of the first memory is done by the clearing part on the low left side of the first memory

One of the solution could be using an external clock to define when the action should be taken but, to keep our simulated circuit as easy as possible, we decided to simply address the problem in the report.


\subsubsection{Falling edge}

After the button is released the circuit transit to falling edge.
The process is similar to the preceden; the first line to change this time is the one below the second memory, this line has, like the one in the first memory,the job of resetting the memory.

Right after it's the line on top of the second memory that switch on permitting the last one to store the information outputted from the first memory.

The last line to switch is, like before, the one on top of the first memory that switch from high to low and stop the memory from being modified.

\vspace{3mm}

The problem described at the end of the rising edge is in fact a problem that start at the rising edge and end at the falling edge. 

Since the first memory work in the rising edge while the second work in the falling edge the same problem will apply to the second memory but the problem solve just as before.


\subsubsection{Multiplication}

The work of the adders isn't during the falling edge or the rising edge but is instead  between the two.

\vspace{3mm}

The second adder, highlighted in red, is the one responsible of multiplying 10 to the previous number and work between falling edge and rising edge

To do a multiplication in binary you need to shift the number as much as the bit of the multiplier and add all the result. For example let's take $6 \cdot 10$, writing it in binary we obtain 
$0110 \cdot 1010$. if we subdivide the multiplication if $0110 \cdot 1000$ and $0110 \cdot 0010$ we can simply shift the number. 
after this we add the two result $101000 + 001010 = 110010$ and the result that we obtain correspond with 60.

\vspace{3mm}

to do this operation we simply make the input go to the second and fourth entrance of the adder and take in output the result multiplied by 10. Since the multiplier is 10 we can see that the first bit of the result will always be low and that the first three number of the result don't need any addition so we can directly take result without passing by a full adder.


\subsubsection{Adder}

The first adder, highlighted in blue, has the job of adding the previous number, multiplied by 10, and the new number in input. this second adder work between the rising edge and the falling edge.



\subsection{Sign bit}

To do the subtraction we could have used the full subtractor but we decided to use the addition between positive and negative number in binary. To do the subtraction we needed a way to read if the second number is positive or negative. As visible in Immage %number of the immage
wesimply used a flip flop. 
From the top the first line is the input $+$, the second is the input for $-$ the third is the clear button that also reset the sign bit.

%immage of the sign bit



\subsection{Memory}
The final part of the input is the two memory in Immage %number of immage (memory)
.

%immage of the memory

\vspace{3mm}

The first memory, highlighted in green, is the one where we save the first number. 
Knowing that the first number is always positive we can save the memory and give the output to the processing part just as it is. 
Since we want this memory to be modified only when it has to register the first number we added the AND "line" that is controlled by the line exiting the OR in Immage%number of immage (sign bit)
; with this the memory will store information only when $+$ or $-$ are inputted. the line is also connected at the right side of the memory to a line that clear the memory from immage%number of immage (10x multiplier)
 making possible to input the second number.

\vspace{3mm}

The second memory, highlighted in yellow, work in the same way as the first one but take the check at the input is done with the $=$ sign instead.

One difference between the first and second memory are the XOR gate at the output of the second memory. The XOR take on one input the respective bit and on the other the sign bit. After XOR the output will stay the same if the sign bit is positive and invrted if negative; this is done to do the addition between a negative and a positive. 

\vspace{3mm}

To see the complete process about the addition of positive and negative number check chapter %number of the processing chapter

\subsection{Clear}

The last kind input, of wich we still haven't talk, is the clear button, necessary to use the circuit more than one time. 
This button is connect to the reset line of all the memory and the sign bit and switch all the memories to 0. 

\end{document}