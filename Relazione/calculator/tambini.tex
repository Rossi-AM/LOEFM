\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{amsmath,amssymb}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{steinmetz}
\usepackage{stackrel}
\usepackage{mathtools}
\newcommand{\angstrom}{\text{\normalfont\AA}}

\geometry{a4paper}

\usepackage[english]{babel}
\frenchspacing

\title{Report: adder and subtractor}
\author{Lorenzo Ramella, Alessandro Matteo Rossi, Marco Tambini}
\date{\today}

\begin{document}
\maketitle

\tableofcontents

\clearpage

\section{Basics concepts}

\subsection{Boolean algebra}
To make calculations, a circuit needs to be able to perform logical operations. In particular, we usually use boolean algebra in digital electronics. 

\vspace{3mm}

To be able to create a circuit like this, first of all, we need to define the various components.
The number 0 and 1 need to be properties of an electrical circuit that can be "moved" and they can be realized using voltage. We can assign the number 0 to a low voltage and the number 1 to a high voltage. 

\vspace{3mm}

For example, if we define $0\,\textrm{V}$ as low, negative or 0 and $5\,\textrm{V}$ as high, positive or 1, we can define a threshold voltage exactly in the middle, so that any voltage under $2.5\,\textrm{V}$ will be considered 0, and any voltage above it will be considered 1.

\vspace{3mm}

Once 1 and 0 are defined, we need to define the operations that can be performed:

\begin{itemize}
\item $"!"$ is the negation, and it can be represented by a NOT gate.
\item $"+"$ is the addition, and it can be represented by an OR gate.
\item $"*"$ is the multiplication, and it can be represented by an AND gate.
\end{itemize}



\subsection{Classical operations in boolean algebra}

\subsubsection{Addition}

In order to sum up two binary numbers, we perform a classical column sum, keeping track of the carry-overs.



\subsubsection{Subtraction}

Subtracting two binary numbers is slightly more difficult. We point out that, if we consider a binary number $A$, its opposite is
\[-A=NOT(A)+1\]

This means that a subtraction can be performed by summing up a first number $X_1$ and the opposite of the second number $-X_2$. 

\vspace{3mm}

In our project we will use a ripple carry adder, that will be presented in section \ref{RCA_Section}. This component is able to sum $X_1$ with the opposite of $X_2$ and then it will add "1". This is possible thanks to the commutative property.

\vspace{3mm}

Now let's perform a subtraction among $6$ and $3$, which respectively correspond to $0110$ and $0011$. First of all we do
\[0110+NOT(0011) = 0110 + 1100 = (1)0010\]

We leave the last carry-over, if present like in this case, because inputs and output must have the same amount of binary digits.

Then we add "1"

\[(1)0010+1=(1)0011 = 0011\]
  
And this is equal to 3 in decimal form.



\subsubsection{Multiplication}

In order to multiply two binary numbers, you need to subdivide the operation in different phases. The second factor has to be split into numbers with a single "1" bit, and the first factor is multiplied to every single division. Then the results are summed up. The multiplication is a classical multiplication among real numbers. 

\vspace{3mm}

For example let's take $6 \cdot 10$, which is $0110 \cdot 1010$ in binary form. If we subdivide the multiplication in $0110 \cdot 1000$ and $0110 \cdot 0010$, we can simply add up all these results. The result is $110000 + 001100 = 111100$ which corresponds with 60 in decimal form. We specify that the multiplication by 10 is seen as a multiplication by 8 summed to a multiplication by 2.












\section{Logic gates}

When we talk about a logic gate, we are describing a circuit that can take a certain number of inputs and gives a single output, depending on the input received. The output needs to be readable by another logic gate of the same family.

\vspace{3mm}

The main logic gates are the following, represented with their circuital symbol in figure \ref{LogicGates}.

\begin{figure}[h!]

    \centering
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_NOT.PNG}
        \caption{NOT gate}
        \label{NOT}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_AND.PNG}
        \caption{AND gate}
        \label{AND}        
    \end{subfigure}
    
    \centering
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_OR.PNG}
        \caption{OR gate}
        \label{OR}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_XOR.PNG}
        \caption{XOR gate}
        \label{XOR}        
    \end{subfigure}
    
    \centering
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_NAND.PNG}
        \caption{NAND gate}
        \label{NAND}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_NOR.PNG}
        \caption{NOR gate}
        \label{NOR}        
    \end{subfigure}
    
    \centering
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{IM_XNOR.PNG}
        \caption{XNOR gate}
        \label{XNOR}
    \end{subfigure}

\caption{Image of the main logic gates used in digital electronics}
\label{LogicGates}
\end{figure}




\clearpage

\subsection{N-MOS}

In order to create these logic gates, we need to know how to use a MOSFET. For this project we used N-MOS transistors only.

\vspace{3mm}

The N-MOS is a transistor that gets as input a gate voltage, a drain voltage, a source voltage and a body voltage. In most cases the source and the body are internally connected, since the body needs to be at the lowest voltage and the source is usually grounded.

\vspace{3mm}

When a positive voltage is applied between the drain and source, a deplition layer that blocks the current flow is formed. 
If we then start applying a positive voltage between gate and body, the electrons will start "balancing" the gaps in the P substrate, but the current will still be zero.

\vspace{3mm}

After $V_{GS}$ (the potential difference among gate and source) overcomes a certain threshold voltage, the current will start to flow from drain to source. At the beginning of this flow, the ratio between the current and $V_{DS}$ (the potential difference among drain and source) is linear but, when $V_{DS}$ becomes big enough, the function becomes almost constant (see figure \ref{NMOS_Function}) and we find ourself in the saturation region.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.65]{IM_NMOS_Function.png}
    \caption{Graph of the I-V N-MOS function}
    \label{NMOS_Function}
\end{figure}

\vspace{3mm}

We do not need to distinguish linear section and saturation section, as we will check only the voltage at the drain of the N-MOS for our gate. The threshold voltage is different for every transistor, and it usually is within the range $0.5\,\textrm{V} - 5\,\textrm{V}$. The transistor we used is the $IRF822$, whose threshold voltage has been measured in lab, and it is approximately %nV
. We decided to use $5\,\textrm{V}$ for $V_{GS}$ to make input and output approximately the same, as we will see later.


\clearpage


\subsection{NOT gate}

The easiest logic gate to realize is the NOT gate. We remember that the NOT gate negates the only input it receives. We need a high enough resistance and one N-MOS (as represented in figure \ref{NOT_N-MOS}) to realize it.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{IM_NOT_NMOS.JPG}
    \caption{NOT logic gate realized using a N-MOS and a resistor}
    \label{NOT_N-MOS}
\end{figure}

When the input is 0, the N-MOS will not let the current flow and, thanks to Ohm First Law, we know that the voltage drop across the resistor should be 0, so we get the same supply voltage. The read output will be around $5\,\textrm{V}$, so we get a 1 as output.

\vspace{3mm}

When the input is 1, the N-MOS will let the current flow with a small resistance value. Since there is a higher resistance before the N-MOS, almost all the voltage drop will occur on the previous one, and the drain will be almost zero. The read output will be around $0\,\textrm{V}$, so we get a 0 output.

\vspace{3mm}

With this configuration the signal will not be properly negated for high frequencies, and it will be like in the last picture in figure \ref{ResistiveInverter} (it will never reach a 1 state).

A possible solution consists of a combination of N-MOS and P-MOS but, since our calculator does not have to work at such high frequencies, we dismissed this problem.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{IM_inverter_esa.PNG}
    \caption{Inverter N-MOS circuit with a resistive load}
    \label{ResistiveInverter}
\end{figure}

For the picture of the NOT gate realized in laboratory check figure \ref{NOT_LAB} in Appendix.


\clearpage
\subsection{NOR gate}

Once we created the NOT gate, we proceeded to realize the NOR gate since, as we will explain later in Section \ref{OtherGates}, the NOR and the NAND gate are both functional complete.

\vspace{1mm}

The NOR gate is composed, as seen in figure \ref{NOR_N-MOS}, by two NOT gates short-circuited at their output.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.3]{IM_NOR_NMOS.JPG}
    \caption{NOR logic gate realized using two short-circuited NOT gates}
    \label{NOR_N-MOS}
\end{figure}

When both inputs are 0, the two N-MOS will not let any current pass and, just like in the NOT gate, the output will be 1.

\vspace{1mm}

When one or both inputs are 1 the N-MOS will let the current flow and there will be a voltage drop across the resistor. So the output will be 0.

\vspace{1mm}

The role of the short circuit is ensuring that whether an input is positive, the current will pass through the "open" N-MOS.

\vspace{3mm}

For the picture of the NOR gate realized in laboratory check figure \ref{NOR_LAB} in Appendix.



\subsection{NAND gate}

As we said for the NOR gate, the NAND gate is also functional complete. But it can be created without the shortcircuit needed by the NOR gate, so it is slightly cheaper. 

\vspace{3mm}

The NAND gate is realized with a series resistor followed by two N-MOS, where the source of the first is plugged in the drain of the second, as seen in figure \ref{NAND_NMOS}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.25]{IM_NAND_NMOS.JPG}
    \caption{NAND gate realized with one resistor and two N-MOS transistors}
    \label{NAND_NMOS}
\end{figure}

\vspace{3mm}

When both inputs are 1, the current will be able to flow and the output will be 0.

\vspace{1mm}

When one of the inputs is 0, one of the N-MOS will be "closed" and, since the current cannot pass, the output will be 1.

\vspace{3mm}

For the picture of the NAND gate realized in laboratory check figure \ref{NAND_LAB} in Appendix.



\subsection{Other logic gates} \label{OtherGates}

Being functional complete means that a single logic gate can be the only component in a circuit, and that circuit will be equivalent to any other logic gate. NAND and NOR gates have this property (see figure \ref{NAND_allpowerful} and \ref{NOR_allpowerful} in appendix).

\vspace{3mm}

The only gates needed for the calculator are shown in figure \ref{UsefulGates}, and they are: 

\begin{itemize}
\item The AND gate, made by the NAND gate, where the output is negated by a NOT.
\item The OR gate, made by the NOR gate, where the output is negated by a NOT.
\item The XOR gate, made by four NAND gates as shown in figure \ref{XOR_NANDs}
\end{itemize}

\begin{figure}[h]
    \centering
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[scale=.3]{IM_AND_LOGIC.JPG}
        \caption{AND gate built using a negated NAND gate}
    \end{subfigure}
    \hfill
    \begin{subfigure}{.49\textwidth}
        \centering
        \includegraphics[scale=.3]{IM_OR_LOGIC.JPG}
        \caption{OR gate built using a negated NOR gate}       
    \end{subfigure}
    \vspace{2mm}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[scale=.3]{IM_XOR_LOGIC.JPG}
        \caption{XOR gate built using a four NAND gates}     
        \label{XOR_NANDs}     
    \end{subfigure}
    \caption{The logic gates used in the calculator}
    \label{UsefulGates}
\end{figure}
\clearpage
\subsection{Bistable circuit}

For the 16-bit calculator, that will be discussed in section \ref{SimulatedCalculator}, we also needed to be able to store information.

\vspace{1mm}

This means that we need a component that will work as memory. It has to be able to get an input and keep it saved as long as necessary, even if the input signal has already expired. Since the memory has to be both writable and readable, it needs a second input line to clear it.

\vspace{3mm}

The circuit that corresponds to the memory we need is the bistable circuit, also known as flip-flop (shown in figure \ref{FlipFlop}).

\begin{figure}[h]
    \centering
    \includegraphics[scale=.3]{IM_FlipFlop}
    \caption{The circuit used to create a flip-flop memory unit}
    \label{FlipFlop}   
\end{figure}

The flip-flop can be created by both NOR gates and NAND gates but, since the NAND gates are cheaper, we decided to use those. This meant that the input has to be negated in order to work properly. Flip-flop truth table can be found in table \ref{FlipFlopTT}.


\begin{table}[h]
\centering
\begin{tabular}{ | c | c  c  c | c  c |}
\hline
 \# & $Set$ & $Clear$ & $Old Q$ & $New Q$ & $New Q'$\\
\hline
 \ 1 & 0 & 0 & 0 & 1 & 1 \\ 
 \ 2 & 0 & 0 & 1 & 1 & 1 \\
\hline 
 \ 3 & 0 & 1 & 0 & 1 & 0 \\ 
 \ 4 & 0 & 1 & 1 & 1 & 0 \\ 
 \ 5 & 1 & 0 & 0 & 0 & 1 \\
 \ 6 & 1 & 0 & 1 & 0 & 1 \\
\hline
 \ 7 & 1 & 1 & 0 & 0 & 1 \\
 \ 8 & 1 & 1 & 1 & 1 & 0 \\ 
\hline
\end{tabular}
\caption{Flip-flop truth table. Please note that the first two rows are not ideal for the storage of data, as $Q$ and $Q'$ have the same value. Rows 3-6 represent the moment when an input is given, whereas 7 and 8 is when data is stored.}
\label{FlipFlopTT}
\end{table}





\clearpage








\section{Processing components}

In order to create a calculator that could perform additions and subtractions, we needed to have a component able to sum (or subtract) two binary numbers.

\subsection{Half adder}

The easiest component that can do this task is the half adder. It is a small circuit with 2 inputs and two outputs, and it is capable of summing up two binary digits. The input are the two digits, and the outputs are the sum $S$, performed by a XOR gate (which truth table is in figure \ref{XOR}), and the carry-over $C$, calculated by an AND gate (which truth table is in figure \ref{AND}).

\vspace{3mm}

Half adder truth table can be found in table \ref{HalfAdderTT}.

\begin{table}[h]
  \centering
  \begin{tabular}{| c | c || c | c |}
  \hline
  A$_1$ & A$_2$ & S & C \\ \hline
  0 & 0 & 0 & 0 \\ \hline
  1 & 0 & 1 & 0 \\ \hline
  0 & 1 & 1 & 0 \\ \hline
  1 & 1 & 0 & 1 \\ \hline
  \end{tabular}
  \caption{Half adder truth table, where $A_1$ and $A_2$ are the input bits, $S$ is the result, and $C$ the carry-over}
  \label{HalfAdderTT}
\end{table}

The major issue with this component is not being useful during a sum of two binary numbers. We specify that a sum of two binary numbers is a classical column sum. For this reason the half adder is not the best choice, because it cannot track the carry-over of the sum performed on the previous bit, if present.

\subsection{Full adder}

If we want to sum two positive n-bit binary numbers, we need to keep track of the carry-overs. The right component for this duty is a full-adder, whose truth table can be found in table \ref{FullAdderTT}

\begin{table}[h]
  \centering
  \begin{tabular}{| c | c | c || c | c |}
  \hline
  A$_1$ & A$_2$ & C$_{in}$ & S & C$_{out}$ \\ \hline
  0 & 0 & 0 & 0 & 0 \\ \hline
  0 & 1 & 0 & 1 & 0 \\ \hline
  1 & 0 & 0 & 1 & 0 \\ \hline
  1 & 1 & 0 & 0 & 1 \\ \hline
  0 & 0 & 1 & 1 & 0 \\ \hline
  0 & 1 & 1 & 0 & 1 \\ \hline
  1 & 0 & 1 & 0 & 1 \\ \hline
  1 & 1 & 1 & 1 & 1 \\ \hline
  \end{tabular}
  \caption{Full adder truth table. It is possible to see the third input that the half adder does not have, the carry-over of the previous column sum}
  \label{FullAdderTT}
\end{table}

The most efficient way to realize a full adder is shown in figure \ref{FullAdderCircuit}. It requires only 5 logic gates.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.6]{IM_full_adder_bis}
  \caption{Most efficient way to create a full adder, by using two XOR gates, two AND gates and one OR gate}
  \label{FullAdderCircuit}
\end{figure}

\subsection{Ripple carry adder} \label{RCA_Section}

If we align a series of full adders we obtain a ripple carry adder (shortened in RCA).

\vspace{3mm}

This circuit is useful because it can perform not only sums among positive numbers, but also algebraic sums. We point out that in our circuit only the second addend could be negative.

\vspace{3mm}

This happens because, in our circuit, both numbers are considered positive, but the user can pick the subtraction operation, which makes the second addend negative. It is not possible to modify the sign of the first number.

\vspace{3mm}

In figure \ref{RCA_SMALL} you can see a ripple carry adder with a 3-bit input (where one of the bits if the sign bit).

\begin{figure}[h]
  \centering
  \includegraphics[scale=.65]{IM_RCA_SMALL.PNG}
  \caption{3-bit ripple carry adder}
  \label{RCA_SMALL}
\end{figure}

We can list its working steps:
\begin{enumerate}
  \item The digits of the first number (blue wires, one per digit) enter the full adders.
  \item The digits of the second number (green) get compared to the sign bit (red) by two XOR gates. They will exit these gates on the lime wire, and they will enter the full adders too. If the second number is negative, the red wire will be on, and the digits will be inverted, following the rule on how to obtain the opposite of a binary number.
  \item Considering that the opposite of a binary number is $-A=NOT(A)+1$, the "1" is added in the first full adder as a $C_{in}$.
  \item The sum is performed and the result goes to a decoder. The XOR gate on the right side of the image compares the sign bit with the carry-over of the last sum performed (orange). 
  
    \vspace{3mm}

    Let's consider the possible cases of this last XOR gate:
  \begin{enumerate}
    \item If the sign bit is 0 and the carry-over of the last full adder is 0, this means we are summing two positive numbers, which result is positive, as confirmed by the XOR.
    \item If the sign bit is 0 and the carry-over of the last full adder is 1, this means we are experiencing a memory overflow. The result goes beyond the range the calculator can handle.
    \item If the sign bit is 1 and the carry-over of the last full adder is 0, this means we are subtracting two numbers, and the second has a greater module. So the result is negative.
    \item If the sign bit is 1 and the carry-over of the last full adder is 1, this means we are subtracting two numbers, and the first has a greater module. So the result is positive.
  \end{enumerate}
\end{enumerate}




\clearpage

\section{16-bit calculator} \label{SimulatedCalculator}



\subsection{Input with 16-bit}

Our goal is to create a 16-bit calculator. It has to receive 16 bits as input and that produces 17 output bits (the 17th is the sign bit).

\vspace{3mm}

One of the problems that arise when we want to use such a big memory space is the increasement in complexity; this makes the circuit more expensive and also takes a lot of physical space, that could be used for other purposes. In a small scale, we could use a 2-bit priority encoder, but, for our project, it would be unpractical and unnecessarily harder.

\vspace{3mm}

Another problem regarding the priority encoder, is that this component would require more physical space. We would need an input line for every single number we could insert. Considering that the possible inputs are all the natural numbers in the interval $[0,2^{16})$, we would need $2^{16}$ input lines.

\vspace{3mm}

To solve both problems we decided to use a keyboard. It takes the input through some buttons, instead of the levers we used in the laboratory. This method solved both the problem with the number of inputs and the problem of the complexity of the decoder.



\subsection{Keyboard}

The keyboard part connects a point at high voltage to the rest of the circuits. It is composed by: 

\begin{itemize}
    \item 10 buttons for the digits from 0 to 9;
    \item An addition button labeled $+$;
    \item A subtraction button labeled $-$;
    \item A button to have the result displayed, labeled $=$;
    \item A clear button that resets the entire circuit.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=.3]{IM_Keyboard}
    \caption{Picture of the simulated circuited keyboard}
    \label{Keybaord}
\end{figure}

\clearpage

\subsection{4-bit encoder}
The first part of our encoder is a 4-bit encoder, without priority. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=.35]{IM_4BitEncoder.JPG}
    \caption{4-bit encoder}
    \label{encoder}
\end{figure}

As you can see in figure \ref{encoder} this part can be split in three different sections:

\begin{itemize}
    \item The red part is a 4-bit encoder without priority. As we were saying in the paragraph above, the advantage of using a keyboard is that we will, under normal condition, only get 1 input at a time making a priority encoder useless. The encoder works by checking, with an OR gate, which bits the inserted number activates.
    
    \vspace{1mm}

    For example, if we press the button "6" the binary input will be $0110$, so only the second and the third bit will be activated.

    \item The green part is an OR gate connected to all the input lines, in order to check whether a button corresponding to a number is pressed. This choice has been made because if 0 was pressed, it would not result in any binary input, but it would be needed to multiply the previous number by $10$. 

    \item The blue part is a small "flash memory", which gets cleared when the input button is no longer pressed. 
            
        This part, whose functioning relies on the concept of bistable circuit, is a simple "security" method, useful to ensure that the inputs arrive correctly to the next memory. This part could be removed if the circuit timing was perfect, but we preferred to keep it to ensure no problem would arise.    
\end{itemize}


\subsection{Memory and successive inputs}

This part allows the circuit to receive consecutive inputs, and it is composed by two memories and two ripple carry adders. 

\vspace{3mm}

In this section the input gets stored and, after a new button is pressed, the stored number is multiplied by 10 and then added to the new input. By doing this we can obtain every number within the memory limit.
\clearpage
It is important to point out that this part works by using the concepts of "rising edge", where the input passes from a low state to a high one, and "falling edge", where the input changes from high to low. This concept makes possible to process a single input in two phases.

\begin{figure}[h]
    \centering
    \includegraphics[scale=.55]{IM_Converter.PNG}
    \caption{}
    \label{Converter}
\end{figure}


\subsubsection{Rising edge}

When the first button is pressed, the circuit is in a state of "rising edge". In this moment, the horizontal wire that goes to all the NANDs of the second memory (highlighted in yellow in figure \ref{Converter}), switches to low to prevent the NANDs from letting any signal pass from the first to the second memory.

\vspace{3mm}

The second wire involved is the horizontal one under the first memory (highlighted in green), that also turns off. This wire is responsible for clearing the memory. This happens when this wire switches from high to low.

\vspace{3mm}

After a little while, the last wire that changes its state is the one on top of the first memory. This allows a new input to be memorized in the cleared memory.

\vspace{3mm}

It is important to note that, during the data storage, the reset wire (the horizontal one at the bottom of the green box) is in a low state, since it cleared the memory right before the storage of new data.

\vspace{3mm}

This last fact does not cause any trouble when the input is 0, since we are in the case 5 or 6 of the flip-flop truth table (table \ref{FlipFlopTT}) and, as you can see, the output is 0. 

\vspace{3mm}

The problem arises when the input data is 1, since we are in case 1 or 2 of the flip-flop truth table, where the two inputs are 0. As we can see in the truth table, in this case, both outputs are set at 1.

\vspace{3mm}

After one of the two inputs switches from low to high, the flip-flop returns in a normal state (state 3-6). But, to store a bit "1", we need to go from states 1 or 2, to state 4 of the truth table. In other words, as long as the clear line is the first one switching from low to high, we easily pass from state 1-2 to state 4.

\vspace{3mm}

Note that, it is not possible to reach state 3 in the case explained before, because state 1-2 "NewQ" becomes state 4 "OldQ" while state 3 "OldQ" is 0.

\vspace{3mm}

The problem we have just described has been solved in the simulated calculator by using the delay given from the logic gates. In reality, this could be a problem since this relies on physical properties that could depend from temperature, making this kind of timing, whether applied to a real circuit, not as precise as in the simulator.

\vspace{3mm}

The timing problem also includes the fact that the operation on the second memory should be done before the one on the first memory. In our circuit, this delay is performed by the "clearing part" (the XOR gate on bottom left corner of the green box). 

\vspace{3mm}

Another possible solution could be using an external clock to define when the action should be performed. But, in order to keep our simulated circuit as easy as possible, we decided to simply address the problem in this report.




\subsubsection{Falling edge}

After the the number button is released the circuit is in the "falling edge" phase.

\vspace{3mm}

The process is similar to the previous one. The first wire to change its state is the horizontal one below the second memory, this time. Its task is the memory reset, like the one in the first memory. After this, the horizontal wire on top of the second memory changes its state, to allow the second memory to store information coming from the first.

\vspace{3mm}

The last connection that switches is, as before, the horizontal one on top of the first memory. It switches from high to low and prevents any further memory modification.

\vspace{3mm}

The problem described at the end of the rising edge is, in fact, a problem that begins with the rising edge and ends during the falling edge. Since the first memory works during the rising edge phase, and the second one works during the falling edge phase, the second memory will suffer the same problem, and so it will have the same possible solutions explained before.


\subsubsection{Ripple carry adders}

This circuit works with two ripple carry adders.

\vspace{3mm}

During a calculation, the RCAs do not work at the same time. The first RCA, highlighted in blue lets the inserted digit head towards the first memory highlighted in green. Then, this digit passes through the second memory (yellow), during the falling edge phase, and gets multiplied by 10 from the red RCA. This multiplied digit is not used unless a new digit is inserted by the user.

\vspace{3mm}

If a new number button is pressed, this new value gets summed to the previous data, already multiplied by 10, and stored in the green memory. The sum of the two number is performed by the blue RCA.

\vspace{3mm}

If a third digit is inserted, the process repeats again.

\vspace{3mm}

Moreover, we can notice that after multipling by 10, the first bit is always set to 0. The second and the third bits depend only from the first and second bit of the original number, because they are only affected by the multiplication by 2 (0010) and not by the multiplication by 8 (1000). 

From the fourth bit the addition performed by the red RCA is needed because these binary digits are influnced by the 10x multiplication. %rivedere sta parte perch√® ci sto capendo poco io che la sto scrivendo, che cazzo






\subsection{Sign bit}

To do the subtraction we could have used the full subtractor, but we decided to use the addition between positive and negative numbers in binary. To perform the subtraction we needed a way to read whether the second number was positive or negative . As visible in figure \ref{SignBit} we simply used a flip-flop. From the top (coming from the left side):
\begin{itemize}
    \item The first horizontal line is the input $+$;
    \item The second is $-$;
    \item The third is the clear signal, that also resets the sign bit.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=.5]{IM_SignBit}
    \caption{The component used to check a number sign, created with a flip-flop}
    \label{SignBit}
\end{figure}

\clearpage
\subsection{Memory}
The final part of the input is the two memories in figure \ref{Memories}.

\begin{figure}[h]
    \centering  
    \includegraphics[scale=.4]{IM_Memories.PNG}
    \caption{Final part of the input section, composed of two memories, one for each number that needs storage}
    \label{Memories}
\end{figure}

\vspace{3mm}

The first memory, highlighted in green, is where the first number gets stored. Considering that the first number is always positive, we can save it, and give it to the processing section, just as it is. 

\vspace{1mm}

Since we want this memory to be modified only when it has to register the first number, we added the AND wire that is controlled by the wire exiting the OR in figure \ref{SignBit}. 

\vspace{1mm}

With this, the memory will store information only when $+$ or $-$ are pressed. The wire is also connected to the right,side of the memory to a line that clear the memory from immage%number of immage (10x multiplier)
making it possible to input the second number.

\vspace{3mm}

The second memory, highlighted in yellow, works in the same way as the first one but take the check at the input is done with the $=$ sign instead. %eh?

One difference between the first and second memory are the XOR gates beyond the second memory. A XOR takes as first input a bit and as second the sign bit. Then the XOR output will be the same as the first input if the sign bit is positive, and inverted if negative. This is done to perform an addition between a negative and a positive number. 

\vspace{3mm}

To see the complete process about the addition of positive and negative number check section \ref{DEVOMETTERLOZIO}

\subsection{Clear}

The last input, not discussed yet, is the clear button. This button is connected to the reset line of all the memories and the sign bit, and it switches every flip-flop to 0. 

\clearpage
\subsection{Decoder}

After the inputs have been processed (added or subtracted), it is needed a decoder (see figure \ref{Decoder}) in order to convert the output from binary number to its decimal form. Considering that this 16-bit calculator allows the user to insert numbers within the range (INSERIRE IL RANGE CAZZO), the operative boundary of this calculator is (INSERIRE).

\vspace{3mm}

The largest number that can be shown as result is around $\pm$INSERIER (+INSERIER or -INSERIER, to be exact), both positive and negative. So the decoding circuit needs to have 6 led displays for the digits and one extra display for the sign.

\vspace{3mm}

We decided to operate the binary-decimal conversion with the so called "double dabble" circuit, that will be explained later in the report. Nevertheless this was not the main problem. The double-dabble converts positive numbers perfectly, but not negative ones. The major issue was to adapt this circuit to work with both positive and negative numbers. 

The representation of the negative binary numbers follows the "two's complement" rule. It means that taken a B number of bits, all the numbers that can be represented with a 0 in the $B-1$ position are considered positive, otherwise they are negative. This allows to split the 17 bits available in two sets of 16 bits, and so it is possible to have the range described above.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.42]{SC_Decoder}
    \caption{Picture of the decoder}
    \label{Decoder}
  \end{figure}

\subsubsection{About the number sign}

The number sign has to be taken into account before converting the number into its decimal form. The number is a 16-bit binary, as already said, and it has one extra bit for the sign, the 16th bit.


This part of the circuit (represented in figure \ref{Converter}) uses full-adders and XOR logic gates, components that got already discussed in the previous sections. After the processing of the operation between the two inputs, the first 16 bits reach the A input of a specific full adder (the green lines in figure \ref{Converter}), whereas the sign bit follows the red path.

This 16th bit reaches every B input of all the full adders, and also the XOR gates, that compare the result of the single full adders with the 16th bit. The sign bit is true (or 1) when the number is negative and 0 otherwise. This allows the full adders to sum 1, following the formula above, if the processing output is negative, whereas if it is positive the number just stays the same.

After this, the XOR gates, which truth table is 
\begin{center}
\begin{tabular}{||c|c||c||}
    \hline
    A & B & A XOR B \\
    \hline
    0 & 0 & 0 \\
    \hline
    0 & 1 & 1 \\
    \hline
    1 & 0 & 1 \\
    \hline
    1 & 1 & 0 \\
    \hline
\end{tabular}
\end{center}

give the final result, which will go to the double dabble. Considering the full adder output as "A" for the XOR, and the sign bit as "B", it is possible to deduct that when the sign is false (so the processing output is positive) the XOR gates do not modify the full adder output (which do not work too, considering that their "B", the sign bit, is false as well). When the XOR "B" is true (so the processing output is negative), the XOR gives the opposite of its "A" as output.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.43]{SC_Converter.PNG}
    \caption{Picture of the first part of the decoder}
    \label{Converter}
  \end{figure}

\subsubsection{Double dabble}

This second part of the decoder is reached by the number that needs to be converted into decimal form. 

The entire circuit relies on an algorithmic process based on the concept of "shift and add 3", which is the name of the component that mostly populates figure \ref{DoubleDabble}.

This algorithm takes a binary number and after having processed it gives an output divided into smaller parts composed of 4 bits each. Everyone of these parts will be then elaborated by 7 segment decoders and represent a single digit of the decimal number. The 7-segment decoders are obviously connected to 7-segments led displays, that can be seen on the right side of figure \ref{DoubleDabble}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.43]{SC_DoubleDabble}
    \caption{Picture of the double dabble, the second part of the circuit}
    \label{DoubleDabble}
  \end{figure}


The algorithm works as follows (graphic representation in figure \ref{SC_Algo}):
\begin{enumerate}
  \item Let's consider a 8-bit binary number, but the same argument works for n bits. 
  \item Let's consider the units, as long as that binary value is lower or equal to 4, the binary input can keep shifting and increasing the units.
  \item When the units value is an integer greater than 4, 3 is added to them and the shifting process continues.
\end{enumerate}

It is mandatory to add 3 because during the conversion the weight of the 4 bits of the unit is 16, at maximum, whereas those for digits represent a maximum of 10 in decimal form. So to compensate this loss, we add a half of the lost weight.

\begin{table}[h]
  \centering
  \begin{tabular}{||c|c|c|c||c||c||}
    \hline
    \# & Hundreds & Tens & Units & Binary & Operation \\
    \hline
    1 & 0000 & 0000 & 0000 & 11111111 & Start \\
    2 & 0000 & 0000 & 0001 & 11111110 & Shift1 (every 4-bit slot < 5) \\
    3 & 0000 & 0000 & 0011 & 11111100 & Shift2 (every 4-bit slot < 5) \\ 
    4 & 0000 & 0000 & 0111 & 11111000 & Shift3 (every 4-bit slot < 5) \\
    5 & 0000 & 0000 & 1010 & 11110000 & Add-3 to "Units" ("Units" $\geq$ 5)\\
    6 & 0000 & 0001 & 0101 & 11110000 & Shift4 (every 4-bit slot < 5) \\
    7 & 0000 & 0001 & 1000 & 11110000 & Add-3 to "Units" ("Units" $\geq$ 5)\\
    8 & 0000 & 0011 & 0001 & 11100000 & Shift5 (every 4-bit slot < 5) \\
    9 & 0000 & 0110 & 0011 & 11000000 & Shift6 (every 4-bit slot < 5) \\
    10 & 0000 & 1001 & 0011& 11000000 & Add-3 to "Tens" ("Tens" $\geq$ 5)\\
    11 & 0001 & 0010 & 0111& 10000000 & Shift7 (every 4-bit slot < 5) \\
    12 & 0001 & 0010 & 1010& 10000000 & Add-3 to "Units" ("Units" $\geq$ 5)\\
    13 & 0010 & 0101 & 0101& 00000000 & Shift8 (every 4-bit slot < 5) \\
    \hline
  \end{tabular}
    \label{SC_Algo}
    \caption{Double dabble algorithm applied to the decimal number 255}

  \end{table}


The goal of the "Shift and add 3" component, programmed using the customizable logic of the simulator, is to operate this shift or addition depending on the 4 inputs given. Its truth table is figure \ref{Add3Table}.

\begin{table}[h]
  \centering
  \begin{tabular}{||c|c||}
    \hline
    Input & Output \\
    \hline
    0000 & 0000 \\
    0001 & 0001 \\
    0010 & 0010 \\ 
    0011 & 0011 \\
    0100 & 0100 \\
    0101 & 1000 \\
    0110 & 1001 \\
    0111 & 1010 \\
    1000 & 1011 \\
    1001 & 1100 \\
    \hline
  \end{tabular}
    \label{Add3Table}
    \caption{"Shift and add 3" truth table}
  \end{table}

It is clear, thanks to this figure, that when the number is greater than four it gets added three to it. The "shift" part can be seen in figure \ref{DoubleDabble}. If we consider the input A0 of a single Add3 component, when can see that its output, S0, is the input A1 for the next component.

After all this process the number is divided into 4 bit groups that enter the 7-segment decoders and than display the result.






\clearpage
\section{Appendix}

\begin{figure}[h]
    \centering
    \includegraphics[scale=.42]{IM_NAND_allpowerful.png}
    \caption{NAND gate is functional complete, every other logic gate can be a circuit made of NANDs only}
    \label{NAND_allpowerful}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale=.5]{IM_NOR_allpowerful.png}
    \caption{NOR gate is functional complete, every other logic gate can be a circuit made of NORs only}
    \label{NOR_allpowerful}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[scale=.08]{IM_NOT_LAB.jpg}
  \caption{NOT gate realized in laboratory}
  \label{NOT_LAB}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[scale=.08]{IM_NOR_LAB.jpg}
  \caption{NOR gate realized in laboratory}
  \label{NOR_LAB}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[scale=.08]{IM_NAND_LAB.jpg}
  \caption{NAND gate realized in laboratory}
  \label{NAND_LAB}
\end{figure}


\end{document}